import { NextRequest, NextResponse } from 'next/server'
import { requireAuthAPI } from '@/lib/auth/actions'
import { prisma } from '@/lib/config/prisma'
import { processSplitPaymentCompletion } from '@/lib/payments/split-payment'
import { onBookingConfirmed, onPaymentCompleted } from '@/lib/whatsapp/notification-hooks'
import { QRCodeService } from '@/lib/services/qr-code-service'
import { EmailService } from '@/lib/services/email-service'
import { nanoid } from 'nanoid'
import Stripe from 'stripe'

export async function POST(request: NextRequest) {
  try {
    const session = await requireAuthAPI()
    
    if (!session) {
      return NextResponse.json(
        { success: false, error: 'No autorizado' },
        { status: 401 }
      )
    }
    const body = await request.json()
    console.log('üîç Request body completo:', JSON.stringify(body, null, 2))
    const { paymentIntentId, testMode = false, metadata, bookingId } = body

    if (!paymentIntentId) {
      return NextResponse.json(
        { error: 'Se requiere paymentIntentId' },
        { status: 400 }
      )
    }

    console.log('üîç Confirmando pago con:', { paymentIntentId, testMode, metadata, bookingId })
    console.log('üîç BookingId extra√≠do:', bookingId, typeof bookingId)

    // Si estamos en modo de prueba, buscar tanto split payment como pago normal
    if (testMode) {
      console.log('üß™ Confirmando pago en modo de prueba...')
      
      // Primero buscar si es un split payment - verificar que pertenece al club del usuario
      const splitPayment = await prisma.splitPayment.findFirst({
        where: { 
          stripePaymentIntentId: paymentIntentId,
          OR: [
            {
              Booking: {
                clubId: session.clubId
              }
            },
            {
              BookingGroup: {
                clubId: session.clubId
              }
            }
          ]
        },
        include: {
          Booking: {
            include: {
              Club: true,
              Court: true
            }
          },
          BookingGroup: {
            include: {
              Club: true,
              bookings: {
                include: {
                  Court: true
                }
              }
            }
          }
        }
      })

      if (splitPayment) {
        console.log('‚úÖ Split payment encontrado en modo de prueba')
        // Procesar completado del split payment en modo de prueba
        const result = await processSplitPaymentCompletion(splitPayment.id)
        
        // Actualizar split payment como completado
        await prisma.splitPayment.update({
          where: { id: splitPayment.id },
          data: {
            status: 'completed',
            stripeChargeId: `ch_test_${Date.now()}`, // Simular charge ID
            completedAt: new Date()
          }
        })

        console.log('‚úÖ Split payment completado en modo de prueba')

        // üîî TRIGGER SPLIT PAYMENT COMPLETION NOTIFICATIONS, QR AND EMAIL
        try {
          console.log('üîî Triggering split payment completion notification for:', splitPayment.id)
          await onPaymentCompleted(splitPayment.id)
          
          // üî≤ Generate QR Code for the related booking
          if (splitPayment.bookingId) {
            console.log('üî≤ Generating QR code for split payment booking:', splitPayment.bookingId)
            await QRCodeService.generateBookingQR(splitPayment.bookingId)
          }
          
          // üìß Send split payment confirmation email
          console.log('üìß Sending split payment confirmation email for:', splitPayment.id)
          await EmailService.sendSplitPaymentConfirmation(splitPayment.id)
          
        } catch (notificationError) {
          console.error('‚ö†Ô∏è Error sending split payment completion notification:', notificationError)
          // Don't fail the payment - just log the error
        }

        return NextResponse.json({
          success: true,
          paymentConfirmed: true,
          testMode: true,
          ...result
        })
      }

      // Si no es split payment, buscar en payments normales - verificar club
      console.log('üîç No es split payment, buscando pago normal...')
      const payment = await prisma.payment.findFirst({
        where: { 
          stripePaymentIntentId: paymentIntentId,
          OR: [
            {
              Booking: {
                clubId: session.clubId
              }
            },
            {
              BookingGroup: {
                clubId: session.clubId
              }
            }
          ]
        },
        include: {
          Booking: {
            include: {
              Club: true,
              Court: true
            }
          },
          BookingGroup: {
            include: {
              Club: true,
              bookings: {
                include: {
                  Court: true
                }
              }
            }
          }
        }
      })

      if (payment) {
        console.log('‚úÖ Pago normal encontrado en modo de prueba')
        
        // Update payment status
        await prisma.payment.update({
          where: { id: payment.id },
          data: {
            status: 'completed',
            stripeChargeId: `ch_test_${Date.now()}`,
            completedAt: new Date()
          }
        })

        // Update booking payment status
        if (payment.bookingId) {
          await prisma.booking.update({
            where: { id: payment.bookingId },
            data: {
              paymentStatus: 'completed',
              paymentType: 'ONLINE_FULL', // Pagos con Stripe son ONLINE_FULL
              status: 'CONFIRMED'
            }
          })
        } else if (payment.bookingGroupId) {
          await prisma.bookingGroup.update({
            where: { id: payment.bookingGroupId },
            data: {
              paymentStatus: 'completed',
              paymentType: 'ONLINE_FULL', // Pagos con Stripe son ONLINE_FULL
              status: 'CONFIRMED'
            }
          })
        }

        // Create transaction record (check if not already exists)
        const booking = payment.Booking || payment.BookingGroup
        if (booking) {
          // Check if transaction already exists for this payment intent
          const existingTransaction = await prisma.transaction.findFirst({
            where: {
              reference: `stripe_${paymentIntentId}`
            }
          })
          
          if (!existingTransaction) {
            await prisma.transaction.create({
              data: {
                id: nanoid(),
                clubId: booking.clubId,
                type: 'INCOME',
                category: 'BOOKING',
                amount: payment.amount,
                currency: payment.currency,
                description: `Pago online - ${booking.playerName}`,
                date: new Date(),
                reference: `stripe_${paymentIntentId}`,
                bookingId: payment.bookingId, // Solo usar bookingId - Transaction no tiene bookingGroupId
                createdAt: new Date()}
            })
            console.log('‚úÖ Transaction created for payment intent:', paymentIntentId)
          } else {
            console.log('‚ö†Ô∏è Transaction already exists for payment intent:', paymentIntentId)
          }
        }

        console.log('‚úÖ Pago normal completado en modo de prueba')

        // üîî TRIGGER POST-PAYMENT NOTIFICATIONS, QR GENERATION AND EMAILS
        try {
          if (payment.bookingId) {
            console.log('üîî Triggering WhatsApp confirmation for booking:', payment.bookingId)
            await onBookingConfirmed(payment.bookingId)
            
            // üî≤ Generate QR Code for check-in
            console.log('üî≤ Generating QR code for booking:', payment.bookingId)
            await QRCodeService.generateBookingQR(payment.bookingId)
            
            // üìß Send booking confirmation email
            console.log('üìß Sending booking confirmation email for:', payment.bookingId)
            await EmailService.sendBookingConfirmation(payment.bookingId)
            
            // üìß Send payment receipt email
            console.log('üìß Sending payment receipt email for payment:', payment.id)
            await EmailService.sendPaymentReceipt(payment.id)
            
          } else if (payment.bookingGroupId) {
            console.log('üîî Triggering WhatsApp confirmation for booking group:', payment.bookingGroupId)
            await onBookingConfirmed(payment.bookingGroupId)
            
            // üî≤ Generate QR Code for booking group (if method exists)
            console.log('üî≤ Generating QR code for booking group:', payment.bookingGroupId)
            try {
              await QRCodeService.generateBookingQR(payment.bookingGroupId)
            } catch (qrError) {
              console.log('‚ÑπÔ∏è QR generation not available for booking groups yet')
            }
            
            // üìß Send payment receipt email (booking group confirmation)
            console.log('üìß Sending payment receipt email for group payment:', payment.id)
            await EmailService.sendPaymentReceipt(payment.id)
          }
        } catch (notificationError) {
          console.error('‚ö†Ô∏è Error sending post-payment notifications:', notificationError)
          // Don't fail the payment - just log the error
        }

        return NextResponse.json({
          success: true,
          paymentConfirmed: true,
          testMode: true,
          Payment: {
            id: payment.id,
            amount: payment.amount,
            bookingId: payment.bookingId,
            bookingGroupId: payment.bookingGroupId
          }
        })
      }

      if (!payment) {
        // If no regular payment found, check for ClassBooking
        console.log('üîç No es pago normal, buscando ClassBooking...')
        
        // Use the bookingId from the request or try to get it from metadata
        let targetBookingId = bookingId
        if (!targetBookingId && metadata && metadata.booking_id) {
          targetBookingId = metadata.booking_id
        } else if (!targetBookingId && metadata && metadata.class_booking_id) {
          targetBookingId = metadata.class_booking_id
        }
        
        console.log('üîç Buscando ClassBooking con booking ID:', targetBookingId)
        
        let classBooking = null
        if (targetBookingId) {
          // First try to find with processing status - verificar club
          classBooking = await prisma.classBooking.findFirst({
            where: { 
              id: targetBookingId,
              paymentStatus: 'processing',
              Class: {
                clubId: session.clubId
              }
            },
            include: {
              Class: {
                include: {
                  Club: true,
                  Court: true,
                  Instructor: true
                }
              }
            }
          })
          
          console.log('üîç ClassBooking con processing:', classBooking ? 'ENCONTRADO' : 'NO ENCONTRADO')
          
          // If not found with processing, try with pending status (in case it wasn't updated)
          if (!classBooking) {
            console.log('üîç Intentando buscar con pending status...')
            classBooking = await prisma.classBooking.findFirst({
              where: { 
                id: targetBookingId,
                paymentStatus: 'pending'
              },
              include: {
                Class: {
                  include: {
                    Club: true,
                    Court: true,
                    Instructor: true
                  }
                }
              }
            })
            
            console.log('üîç ClassBooking con pending:', classBooking ? 'ENCONTRADO' : 'NO ENCONTRADO')
          }
          
          // If still not found, try without status filter to see if the booking exists at all
          if (!classBooking) {
            console.log('üîç Intentando buscar sin filtro de status...')
            const anyClassBooking = await prisma.classBooking.findFirst({
              where: { 
                id: targetBookingId
              },
              select: {
                id: true,
                studentName: true,
                paymentStatus: true,
                paymentMethod: true
              }
            })
            
            console.log('üîç ClassBooking (cualquier status):', anyClassBooking)
          }
        }
        
        // If not found by ID, try to find by processing status (fallback)
        if (!classBooking) {
          console.log('üîç No encontrado por ID, buscando por estado processing con paymentMethod online...')
          classBooking = await prisma.classBooking.findFirst({
            where: { 
              paymentStatus: 'processing',
              paymentMethod: 'online'
            },
            orderBy: {
              updatedAt: 'desc' // Get the most recent one
            },
            include: {
              Class: {
                include: {
                  Club: true,
                  Court: true,
                  Instructor: true
                }
              }
            }
          })
          
          console.log('üîç ClassBooking con processing+online:', classBooking ? 'ENCONTRADO' : 'NO ENCONTRADO')
          
          // If still not found, try without paymentMethod filter
          if (!classBooking) {
            console.log('üîç Segundo fallback: buscando solo por estado processing...')
            classBooking = await prisma.classBooking.findFirst({
              where: { 
                paymentStatus: 'processing'
              },
              orderBy: {
                updatedAt: 'desc' // Get the most recent one
              },
              include: {
                Class: {
                  include: {
                    Club: true,
                    Court: true,
                    Instructor: true
                  }
                }
              }
            })
            console.log('üîç ClassBooking solo processing:', classBooking ? 'ENCONTRADO' : 'NO ENCONTRADO')
          }
        }

        if (classBooking) {
          console.log('‚úÖ ClassBooking encontrado en modo de prueba')
          
          // Create transaction record for the class payment
          await prisma.transaction.create({
            data: {
              id: nanoid(),
              clubId: classBooking.Class.clubId,
              type: 'INCOME',
              category: 'CLASS',
              amount: classBooking.dueAmount || classBooking.Class.price,
              currency: 'MXN',
              description: `Pago online de clase: ${classBooking.Class.name} - ${classBooking.studentName}`,
              date: new Date(),
              reference: `stripe_${paymentIntentId}`,
              notes: JSON.stringify({
                classId: classBooking.Class.id,
                classBookingId: classBooking.id,
                studentName: classBooking.studentName,
                paymentMethod: 'ONLINE',
                className: classBooking.Class.name,
                stripePaymentIntentId: paymentIntentId
              }),
              createdAt: new Date()}
          })

          // Update ClassBooking payment status
          await prisma.classBooking.update({
            where: { id: classBooking.id },
            data: {
              paymentStatus: 'completed',
              paymentMethod: 'online',
              paidAmount: classBooking.dueAmount || classBooking.Class.price}
          })

          console.log('‚úÖ ClassBooking payment completado en modo de prueba')

          // üîî TRIGGER CLASS BOOKING CONFIRMATION, QR AND EMAIL
          try {
            console.log('üîî Triggering class booking confirmation for:', classBooking.id)
            // For class bookings, we use the classBooking ID as bookingId
            await onBookingConfirmed(classBooking.id)
            
            // üî≤ Generate QR Code for class check-in
            console.log('üî≤ Generating QR code for class booking:', classBooking.id)
            await QRCodeService.generateBookingQR(classBooking.id)
            
            // üìß Send class booking confirmation email
            console.log('üìß Sending class booking confirmation email for:', classBooking.id)
            await EmailService.sendClassBookingConfirmation(classBooking.id)
            
          } catch (notificationError) {
            console.error('‚ö†Ô∏è Error sending class booking confirmation:', notificationError)
            // Don't fail the payment - just log the error
          }

          return NextResponse.json({
            success: true,
            paymentConfirmed: true,
            testMode: true,
            type: 'class',
            classBooking: {
              id: classBooking.id,
              studentName: classBooking.studentName,
              className: classBooking.Class.name,
              amount: classBooking.dueAmount || classBooking.Class.price
            }
          })
        }

        return NextResponse.json(
          { error: 'Pago no encontrado (ni split payment, ni pago normal, ni clase)' },
          { status: 404 }
        )
      }

    } else {
      // Production mode - use real Stripe webhook
      console.log('üè≠ Modo de producci√≥n - usando webhook real de Stripe')
      return NextResponse.json(
        { error: 'Webhook mode not implemented in this endpoint' },
        { status: 501 }
      )
    }

  } catch (error) {
    console.error('Error confirming payment:', error)
    return NextResponse.json(
      { error: 'Error interno del servidor' },
      { status: 500 }
    )
  }
}