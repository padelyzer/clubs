import { NextRequest, NextResponse } from 'next/server'
import { requireAuthAPI } from '@/lib/auth/actions'
import { prisma } from '@/lib/config/prisma'
import { z } from 'zod'

const checkInSchema = z.object({
  studentId: z.string().min(1),
  status: z.enum(['PRESENT', 'ABSENT', 'LATE']).default('PRESENT'),
  notes: z.string().optional()
})

// POST - Check-in student for class
export async function POST(
  request: NextRequest,
  { params }: { params: Promise<{ id: string }> }
) {
  try {
    const session = await requireAuthAPI()
    
    if (!session) {
      return NextResponse.json(
        { success: false, error: 'No autorizado' },
        { status: 401 }
      )
    }
    const paramData = await params
    const { id: classId } = paramData
    const body = await request.json()
    const { studentId, status, notes } = checkInSchema.parse(body)
    
    // Verify class exists and belongs to the user's club
    const classItem = await prisma.class.findFirst({
      where: { 
        id: classId,
        clubId: session.clubId 
      },
      include: {
        instructor: true,
        court: true
      }
    })
    
    if (!classItem) {
      return NextResponse.json(
        { success: false, error: 'Clase no encontrada' },
        { status: 404 }
      )
    }
    
    // Check if student is enrolled
    const enrollment = await prisma.classBooking.findUnique({
      where: { id: studentId },
      include: {
        player: true
      }
    })
    
    if (!enrollment || enrollment.classId !== classId) {
      return NextResponse.json(
        { success: false, error: 'Estudiante no inscrito en esta clase' },
        { status: 400 }
      )
    }
    
    // Update attendance
    const updatedEnrollment = await prisma.classBooking.update({
      where: { id: studentId },
      data: {
        attended: status === 'PRESENT' || status === 'LATE',
        attendanceStatus: status,
        attendanceNotes: notes}
    })
    
    // If marking as present, register instructor expense
    if ((status === 'PRESENT' || status === 'LATE') && !enrollment.attended) {
      if (classItem.instructor) {
        // Calculate instructor payment based on individual instructor configuration
        let instructorPayment = 0
        
        if (classItem.Instructor.paymentType === 'HOURLY') {
          // Calculate based on class duration and instructor's hourly rate
          const hours = classItem.duration / 60
          instructorPayment = Math.round((classItem.Instructor.hourlyRate || 0) * hours)
        } else if (classItem.Instructor.paymentType === 'MONTHLY') {
          // Monthly instructors don't get paid per class - skip automatic expense
          instructorPayment = 0
        }
        
        // Only register expense if this is the first student checking in
        const firstCheckIn = await prisma.classBooking.findFirst({
          where: {
            classId,
            attended: true,
            id: { not: studentId }
          }
        })
        
        if (!firstCheckIn && instructorPayment > 0) {
          // Create expense transaction for instructor payment
          await prisma.transaction.create({
            data: {
              clubId: classItem.clubId,
              type: 'EXPENSE',
              category: 'SALARY',
              amount: instructorPayment,
              currency: 'MXN',
              description: `Pago a instructor ${classItem.Instructor.name} - Clase: ${classItem.name}`,
              date: new Date(),
              reference: `INSTRUCTOR_${classId}`,
              notes: JSON.stringify({
                classId,
                instructorId: classItem.instructorId,
                instructorName: classItem.Instructor.name,
                className: classItem.name,
                classDate: classItem.date,
                classType: classItem.type,
                classDuration: classItem.duration,
                paymentType: classItem.Instructor.paymentType,
                hourlyRate: classItem.Instructor.hourlyRate,
                monthlyRate: classItem.Instructor.monthlyRate,
                studentsCount: classItem.currentStudents,
                hours: classItem.duration / 60,
                attendanceTriggered: true
              })
            }
          })
          
          console.log(`Instructor payment registered: ${instructorPayment / 100} MXN for class ${classItem.name}`)
        }
      }
      
      // Optional: Create a reminder for student payment if pending
      if (enrollment.paymentStatus === 'pending') {
        console.log(`Payment pending for student ${enrollment.studentName}`)
      }
    }
    
    // Get updated attendance stats for the class
    const attendanceStats = await prisma.classBooking.groupBy({
      by: ['attendanceStatus'],
      where: { classId },
      _count: true
    })
    
    const stats = {
      present: 0,
      late: 0,
      absent: 0,
      pending: 0
    }
    
    const totalEnrolled = await prisma.classBooking.count({
      where: { classId }
    })
    
    attendanceStats.forEach(stat => {
      if (stat.attendanceStatus === 'PRESENT') stats.present = stat._count
      else if (stat.attendanceStatus === 'LATE') stats.late = stat._count
      else if (stat.attendanceStatus === 'ABSENT') stats.absent = stat._count
    })
    
    stats.pending = totalEnrolled - (stats.present + stats.late + stats.absent)
    
    return NextResponse.json({
      success: true,
      message: `Check-in exitoso para ${enrollment.studentName}`,
      enrollment: updatedEnrollment,
      attendanceStats: stats
    })
    
  } catch (error) {
    console.error('Error in attendance check-in:', error)
    
    if (error instanceof z.ZodError) {
      return NextResponse.json(
        { success: false, error: 'Datos inválidos', details: error.errors },
        { status: 400 }
      )
    }
    
    return NextResponse.json(
      { success: false, error: 'Error al registrar asistencia' },
      { status: 500 }
    )
  }
}

// GET - Get attendance list for a class
export async function GET(
  request: NextRequest,
  { params }: { params: Promise<{ id: string }> }
) {
  try {
    const session = await requireAuthAPI()
    
    if (!session) {
      return NextResponse.json(
        { success: false, error: 'No autorizado' },
        { status: 401 }
      )
    }
    const paramData = await params
    const { id: classId } = paramData
    
    const classItem = await prisma.class.findFirst({
      where: { 
        id: classId,
        clubId: session.clubId 
      },
      include: {
        instructor: true,
        court: true,
        bookings: {
          include: {
            player: true
          },
          orderBy: { studentName: 'asc' }
        }
      }
    })
    
    if (!classItem) {
      return NextResponse.json(
        { success: false, error: 'Clase no encontrada' },
        { status: 404 }
      )
    }
    
    // Calculate attendance statistics
    const stats = {
      total: classItem.bookings.length,
      present: classItem.bookings.filter((b: any) => b.attendanceStatus === 'PRESENT').length,
      late: classItem.bookings.filter((b: any) => b.attendanceStatus === 'LATE').length,
      absent: classItem.bookings.filter((b: any) => b.attendanceStatus === 'ABSENT').length,
      pending: classItem.bookings.filter((b: any) => !b.attendanceStatus).length,
      paidCount: classItem.bookings.filter((b: any) => b.paymentStatus === 'completed').length,
      unpaidCount: classItem.bookings.filter((b: any) => b.paymentStatus === 'pending').length
    }
    
    // Format attendance list
    const attendanceList = classItem.bookings.map(booking => ({
      id: booking.id,
      studentName: booking.studentName,
      studentPhone: booking.studentPhone,
      studentEmail: booking.studentEmail,
      player: booking.player,
      attended: booking.attended,
      attendanceStatus: booking.attendanceStatus || 'PENDING',
      attendanceTime: booking.attendanceTime,
      attendanceNotes: booking.attendanceNotes,
      paymentStatus: booking.paymentStatus,
      paidAmount: booking.paidAmount,
      enrollmentDate: booking.enrollmentDate
    }))
    
    return NextResponse.json({
      success: true,
      class: {
        id: classItem.id,
        name: classItem.name,
        date: classItem.date,
        time: `${classItem.startTime} - ${classItem.endTime}`,
        instructor: classItem.instructor?.name,
        court: classItem.court?.name,
        status: classItem.status
      },
      attendance: attendanceList,
      stats
    })
    
  } catch (error) {
    console.error('Error fetching attendance:', error)
    return NextResponse.json(
      { success: false, error: 'Error al obtener lista de asistencia' },
      { status: 500 }
    )
  }
}

// PUT - Update multiple attendance records at once
export async function PUT(
  request: NextRequest,
  { params }: { params: Promise<{ id: string }> }
) {
  try {
    const session = await requireAuthAPI()
    
    if (!session) {
      return NextResponse.json(
        { success: false, error: 'No autorizado' },
        { status: 401 }
      )
    }
    const paramData = await params
    const { id: classId } = paramData
    const body = await request.json()
    
    // Verify class exists and belongs to the user's club
    const classExists = await prisma.class.findFirst({
      where: { 
        id: classId,
        clubId: session.clubId 
      }
    })
    
    if (!classExists) {
      return NextResponse.json(
        { success: false, error: 'Clase no encontrada' },
        { status: 404 }
      )
    }
    
    // Expect an array of attendance updates
    const updates = z.array(z.object({
      studentId: z.string(),
      status: z.enum(['PRESENT', 'ABSENT', 'LATE']),
      notes: z.string().optional()
    })).parse(body.updates)
    
    // Batch update attendance
    const updatePromises = updates.map(update => 
      prisma.classBooking.update({
        where: { id: update.studentId },
        data: {
          attended: update.status === 'PRESENT' || update.status === 'LATE',
          attendanceTime: update.status === 'PRESENT' || update.status === 'LATE' ? new Date() : null,
          attendanceStatus: update.status,
          attendanceNotes: update.notes}
      })
    )
    
    await Promise.all(updatePromises)
    
    // Update class status if needed
    const now = new Date()
    const classItem = await prisma.class.findUnique({
      where: { id: classId }
    })
    
    if (classItem) {
      const classDate = new Date(classItem.date)
      const [hours, minutes] = classItem.startTime.split(':').map(Number)
      classDate.setHours(hours, minutes, 0, 0)
      
      // If class has started, mark it as in progress
      if (now >= classDate && classItem.status === 'SCHEDULED') {
        await prisma.class.update({
          where: { id: classId },
          data: { status: 'IN_PROGRESS' }
        })
      }
    }
    
    return NextResponse.json({
      success: true,
      message: `Asistencia actualizada para ${updates.length} estudiantes`
    })
    
  } catch (error) {
    console.error('Error updating attendance:', error)
    
    if (error instanceof z.ZodError) {
      return NextResponse.json(
        { success: false, error: 'Datos inválidos', details: error.errors },
        { status: 400 }
      )
    }
    
    return NextResponse.json(
      { success: false, error: 'Error al actualizar asistencia' },
      { status: 500 }
    )
  }
}