import { NextRequest, NextResponse } from 'next/server'
import { prisma } from '@/lib/config/prisma'
import { requireAuthAPI } from '@/lib/auth/actions'

// GET: Obtener conflictos del torneo
export async function GET(
  req: NextRequest,
  { params }: { params: Promise<{ id: string }> }
) {
  try {
    const session = await requireAuthAPI()
    
    if (!session) {
      return NextResponse.json(
        { success: false, error: 'No autorizado' },
        { status: 401 }
      )
    }
    
    const paramData = await params
    const { id } = paramData

    // Para SUPER_ADMIN, permitir acceso a cualquier torneo
    const whereClause = session.role === 'SUPER_ADMIN' 
      ? { id }
      : { id, clubId: session.clubId }

    // Verificar que el torneo existe
    const tournament = await prisma.tournament.findUnique({
      where: whereClause
    })

    if (!tournament) {
      return NextResponse.json(
        { error: 'Torneo no encontrado' },
        { status: 404 }
      )
    }

    // Obtener todos los partidos con conflictos pendientes
    const matchesWithConflicts = await prisma.tournamentMatch.findMany({
      where: {
        tournamentId: id,
        ResultSubmissions: {
          some: {
            conflictStatus: 'pending'
          }
        }
      },
      include: {
        ResultSubmissions: {
          where: {
            conflictStatus: 'pending'
          },
          orderBy: {
            submittedAt: 'desc'
          }
        }
      }
    })

    // Formatear los conflictos
    const conflicts = matchesWithConflicts.map(match => {
      const results = match.ResultSubmissions || []
      const team1Result = results.find((r: any) => r.submittedBy === 'team1')
      const team2Result = results.find((r: any) => r.submittedBy === 'team2')

      return {
        matchId: match.id,
        team1Name: match.team1Name,
        team2Name: match.team2Name,
        courtNumber: match.courtNumber,
        scheduledAt: match.scheduledAt,
        team1Result: team1Result ? {
          sets: team1Result.team1Sets,
          totalSets: team1Result.team1TotalSets,
          winner: team1Result.winner,
          submittedAt: team1Result.submittedAt
        } : null,
        team2Result: team2Result ? {
          sets: team2Result.team2Sets,
          totalSets: team2Result.team2TotalSets,
          winner: team2Result.winner,
          submittedAt: team2Result.submittedAt
        } : null,
        conflictedAt: team1Result?.submittedAt || team2Result?.submittedAt
      }
    })

    // También obtener partidos pendientes de confirmación (solo un equipo reportó)
    const pendingResults = await prisma.tournamentMatch.findMany({
      where: {
        tournamentId: id,
        status: 'IN_PROGRESS',
        ResultSubmissions: {
          some: {
            confirmed: false,
            conflictStatus: null
          }
        }
      },
      include: {
        ResultSubmissions: {
          where: {
            confirmed: false
          }
        },
        Court: true
      }
    })

    // Filtrar para obtener solo los que tienen exactamente 1 resultado
    const pendingConfirmation = pendingResults.filter(match => 
      match.resultSubmissions.length === 1
    ).map(match => {
      const result = match.resultSubmissions[0]
      return {
        matchId: match.id,
        team1Name: match.team1Name,
        team2Name: match.team2Name,
        courtNumber: match.courtNumber,
        scheduledAt: match.scheduledAt,
        reportedBy: result.submittedBy,
        submittedAt: result.submittedAt,
        waitingTime: Date.now() - new Date(result.submittedAt).getTime()
      }
    })

    return NextResponse.json({
      success: true,
      data: {
        conflicts,
        pendingConfirmation,
        conflictsCount: conflicts.length,
        pendingCount: pendingConfirmation.length
      }
    })
  } catch (error) {
    console.error('Error fetching tournament conflicts:', error)
    return NextResponse.json(
      { error: 'Error al obtener conflictos del torneo' },
      { status: 500 }
    )
  }
}