import { NextRequest } from 'next/server'
import { generateId } from '@/lib/utils/generate-id'

export interface LogContext {
  userId?: string
  clubId?: string
  requestId?: string
  traceId?: string
  sessionId?: string
  action?: string
  resource?: string
  ip?: string
  userAgent?: string
  [key: string]: any
}

export interface LogEntry {
  timestamp: string
  level: 'debug' | 'info' | 'warn' | 'error' | 'fatal'
  message: string
  context?: LogContext
  error?: {
    name: string
    message: string
    stack?: string
    code?: string
  }
  performance?: {
    duration: number
    memory?: number
    startTime: number
  }
}

class Logger {
  private isDevelopment = process.env.NODE_ENV === 'development'
  private serviceName = process.env.NEXT_PUBLIC_APP_NAME || 'padelyzer'
  private environment = process.env.NODE_ENV || 'development'

  private createLogEntry(
    level: LogEntry['level'],
    message: string,
    context?: LogContext,
    error?: Error,
    performance?: LogEntry['performance']
  ): LogEntry {
    const entry: LogEntry = {
      timestamp: new Date().toISOString(),
      level,
      message
    }

    if (context) {
      entry.context = {
        ...context,
        service: this.serviceName,
        environment: this.environment
      }
    }

    if (error) {
      entry.error = {
        name: error.name,
        message: error.message,
        stack: error.stack,
        code: (error as any).code
      }
    }

    if (performance) {
      entry.performance = performance
    }

    return entry
  }

  private output(entry: LogEntry): void {
    if (this.isDevelopment) {
      // Pretty print for development
      const { timestamp, level, message, context, error } = entry
      const time = new Date(timestamp).toLocaleTimeString()

      const levelColors = {
        debug: '\x1b[36m', // cyan
        info: '\x1b[32m',  // green
        warn: '\x1b[33m',  // yellow
        error: '\x1b[31m', // red
        fatal: '\x1b[35m', // magenta
      }

      const reset = '\x1b[0m'
      const levelColor = levelColors[level] || ''

      console.log(`${levelColor}[${level.toUpperCase()}]${reset} ${time} ${message}`)

      if (context && Object.keys(context).length > 0) {
        console.log('  Context:', JSON.stringify(context, null, 2))
      }

      if (error) {
        console.error('  Error:', error.message)
        if (error.stack) {
          console.error('  Stack:', error.stack)
        }
      }
    } else {
      // Structured JSON for production
      console.log(JSON.stringify(entry))
    }

    // In production, also send to external service
    if (!this.isDevelopment) {
      this.sendToExternalService(entry)
    }
  }

  private async sendToExternalService(entry: LogEntry): Promise<void> {
    try {
      // Send to Axiom, DataDog, or similar service
      if (process.env.AXIOM_TOKEN && process.env.AXIOM_DATASET) {
        await fetch('https://api.axiom.co/v1/datasets/' + process.env.AXIOM_DATASET + '/ingest', {
          method: 'POST',
          headers: {
            'Authorization': `Bearer ${process.env.AXIOM_TOKEN}`,
            'Content-Type': 'application/json'
          },
          body: JSON.stringify([entry])
        })
      }

      // Or send to Sentry for errors
      if (entry.level === 'error' || entry.level === 'fatal') {
        if (typeof window !== 'undefined' && (window as any).Sentry) {
          (window as any).Sentry.captureException(new Error(entry.message), {
            contexts: { logger: entry.context },
            tags: { level: entry.level }
          })
        }
      }
    } catch (error) {
      // Fallback to console if external service fails
      console.error('Failed to send log to external service:', error)
    }
  }

  // Extract context from request
  public extractRequestContext(request: NextRequest, additionalContext?: LogContext): LogContext {
    const requestId = request.headers.get('x-request-id') ||
                     request.headers.get('x-trace-id') ||
                     generateId()

    return {
      requestId,
      ip: request.ip || request.headers.get('x-forwarded-for') || 'unknown',
      userAgent: request.headers.get('user-agent') || 'unknown',
      method: request.method,
      url: request.url,
      ...additionalContext
    }
  }

  // Log levels
  public debug(message: string, context?: LogContext): void {
    this.output(this.createLogEntry('debug', message, context))
  }

  public info(message: string, context?: LogContext): void {
    this.output(this.createLogEntry('info', message, context))
  }

  public warn(message: string, context?: LogContext): void {
    this.output(this.createLogEntry('warn', message, context))
  }

  public error(message: string, error?: Error, context?: LogContext): void {
    this.output(this.createLogEntry('error', message, context, error))
  }

  public fatal(message: string, error?: Error, context?: LogContext): void {
    this.output(this.createLogEntry('fatal', message, context, error))
  }

  // Performance logging
  public startTimer(label: string): () => void {
    const startTime = performance.now()

    return () => {
      const duration = performance.now() - startTime
      this.info(`Performance: ${label}`, {
        performance: {
          duration: Math.round(duration * 100) / 100,
          startTime: Date.now() - duration
        }
      })
    }
  }

  // Security logging
  public security(event: string, context?: LogContext): void {
    this.warn(`SECURITY: ${event}`, {
      ...context,
      category: 'security'
    })
  }

  // Database logging
  public database(query: string, duration: number, context?: LogContext): void {
    this.debug(`Database Query: ${duration}ms`, {
      ...context,
      category: 'database',
      query: query.substring(0, 200), // Truncate long queries
      duration
    })
  }

  // API logging
  public apiRequest(method: string, path: string, statusCode: number, duration: number, context?: LogContext): void {
    const level = statusCode >= 500 ? 'error' : statusCode >= 400 ? 'warn' : 'info'

    this.output(this.createLogEntry(level, `${method} ${path} ${statusCode}`, {
      ...context,
      category: 'api',
      method,
      path,
      statusCode,
      performance: {
        duration: Math.round(duration * 100) / 100,
        startTime: Date.now() - duration
      }
    }))
  }
}

// Export singleton instance
export const logger = new Logger()

// Helper for API routes
export function withLogging<T extends any[]>(
  handler: (...args: T) => Promise<Response>,
  operationName: string
) {
  return async (...args: T): Promise<Response> => {
    const startTime = performance.now()
    const request = args[0] as NextRequest
    const context = logger.extractRequestContext(request, { operation: operationName })

    logger.info(`Starting ${operationName}`, context)

    try {
      const response = await handler(...args)
      const duration = performance.now() - startTime

      logger.apiRequest(
        request.method,
        new URL(request.url).pathname,
        response.status,
        duration,
        context
      )

      return response
    } catch (error) {
      const duration = performance.now() - startTime
      logger.error(`Failed ${operationName}`, error as Error, {
        ...context,
        duration
      })
      throw error
    }
  }
}

// Helper for React components
export function useLogger() {
  return {
    debug: logger.debug.bind(logger),
    info: logger.info.bind(logger),
    warn: logger.warn.bind(logger),
    error: logger.error.bind(logger),
    fatal: logger.fatal.bind(logger),
    security: logger.security.bind(logger),
    startTimer: logger.startTimer.bind(logger)
  }
}