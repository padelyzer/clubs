import { Axiom } from '@axiomhq/js';

// Initialize Axiom client
const axiom = process.env.AXIOM_TOKEN 
  ? new Axiom({
      token: process.env.AXIOM_TOKEN,
      orgId: process.env.AXIOM_ORG_ID
    })
  : null;

// Log levels
export enum LogLevel {
  DEBUG = 'debug',
  INFO = 'info',
  WARN = 'warn',
  ERROR = 'error',
  CRITICAL = 'critical'
}

// Structured logger
export class Logger {
  private dataset: string;
  private context: Record<string, any>;

  constructor(dataset?: string, context?: Record<string, any>) {
    this.dataset = dataset || process.env.AXIOM_DATASET || 'padelyzer';
    this.context = context || {};
  }

  private async log(
    level: LogLevel,
    message: string,
    data?: Record<string, any>
  ) {
    const logEntry = {
      timestamp: new Date().toISOString(),
      level,
      message,
      ...this.context,
      ...data,
      environment: process.env.NODE_ENV
    };

    // Always log to console
    const consoleMethod = level === LogLevel.ERROR || level === LogLevel.CRITICAL 
      ? console.error 
      : level === LogLevel.WARN 
      ? console.warn 
      : console.log;
    
    consoleMethod(`[${level.toUpperCase()}]`, message, data || '');

    // Send to Axiom if configured
    if (axiom && process.env.NODE_ENV === 'production') {
      try {
        await axiom.ingest(this.dataset, [logEntry]);
      } catch (error) {
        console.error('Failed to send log to Axiom:', error);
      }
    }
  }

  debug(message: string, data?: Record<string, any>) {
    return this.log(LogLevel.DEBUG, message, data);
  }

  info(message: string, data?: Record<string, any>) {
    return this.log(LogLevel.INFO, message, data);
  }

  warn(message: string, data?: Record<string, any>) {
    return this.log(LogLevel.WARN, message, data);
  }

  error(message: string, error?: Error | any, data?: Record<string, any>) {
    return this.log(LogLevel.ERROR, message, {
      ...data,
      error: error?.message || error,
      stack: error?.stack
    });
  }

  critical(message: string, error?: Error | any, data?: Record<string, any>) {
    return this.log(LogLevel.CRITICAL, message, {
      ...data,
      error: error?.message || error,
      stack: error?.stack
    });
  }

  // Create a child logger with additional context
  child(context: Record<string, any>) {
    return new Logger(this.dataset, {
      ...this.context,
      ...context
    });
  }
}

// Export default loggers
export const logger = new Logger();
export const authLogger = logger.child({ component: 'auth' });
export const apiLogger = logger.child({ component: 'api' });
export const dbLogger = logger.child({ component: 'database' });
export const paymentLogger = logger.child({ component: 'payment' });